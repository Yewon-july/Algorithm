### 반복자(iterator)

- C++ 라이브러리에서는 반복자를 제공하는데, 이것들을 사용하려면 라이브러리 방식대로 __자료구조__로 접근해야 함.
- 따라서, 라이브러리가 __효과적으로 동작__ 할 수 있다는 것을 보장한다는 장점.
- 반복자는 __컨테이너__ 를 다루는 기본적인 기술
- 컨테이너에 요소를 __삽입, 삭제, 검색__ 한 결과를 리턴할 때, 반복자가 필요.
- 알고리즘마다 각기 다른 방식으로 __컨테이너에 접근__하기에, 반복자의 종류도 여러가지가 있음.



### 반복자의 성질

- 컨테이너와 컨테이너 안의 요소를 __구별__ 할 때, 요소의 값을 __확인__ 할 때 사용.
- 컨테이너 안에 있는 __요소들 간의 이동을 할 수 있게 연산 제공__
- 컨테이너가 효과적으로 처리할 수 있는 방식으로 가용한 연산들을 한정



### 구간(range)

- 컨테이너에 담긴 값들의 시퀀스
- 반복자는 한 쌍으로 나타내져야 하며, 이 반복자들이 각각 시퀀스의 처음과 끝을 가리킴.
- 반복자의 범위 내에 있는 값은 물리적으로 __연속되어야 할 필요가 없음__
- 하지만, 1. 두 개의 반복자가 __같은 컨테이너로부터 생성__되어야 함 2. 두 번째 반복자는 __첫 번째 반복자 이후__에 와야 함.

- 첫 번째 반복자가 두 번째 반복자까지 순차적으로 돌면서 내부의 원소를 처리하게 도므로, __논리적인 연속성__ 을 지닌다고 볼 수 있음.
- 포인터가 null을 가질 수 있듯, 반복자도 null 값을 가질 수 있음.
- 널 포인터를 참조하면 에러가 발생하듯, 널 반복자를 참조해도 __에러가 발생__



### end()는 끝이 아니다.

- end()는 컨테이너의 마지막 원소를 가리키는 것이 아니라, __마지막 원소의 다음 원소를 가리킴__.
- 즉, 아무 것도 없는 곳을 가리키는 것.
- end()부분을 참조하려하면 __에러가 발생__
- 이러한 반복자를 __past-the-end__ 반복자라고 부름. 종점을 지나쳐버린 곳을 가리키는 반복자라는 뜻.
- 컨테이너 안에 아무런 원소가 없으면 __begin() = end()__



### 반복자 구간(iterator range)

- 반복자 2개를 사용하여, 컨테이너의 특정 구간에 속한 원소들을 나타내고자 한다면, 첫 번째 반복자가 두 번째 반복자까지 __도달 가능해야 함__. 그렇지 않으면 __에러 발생__.
- 이는 알고리즘이나 컨테이너 등의 내부에서 검사를 해주지 않기 때문에, __프로그래머가 직접 처리해주어야 함__



### 반복자의 종류

| 종류                                     | 기능                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| 입력 반복자(input iterator)              | 1. 읽기만 가능.<br />2. 순방향 이동<br />3. 현 위치의 원소를 한 번에 읽을 수 있는 반복자. |
| 출력 반복자(output iterator)             | 1. 쓰기만 가능<br />2. 순방향 이동<br />3. 현 위치의 원소를 한 번에 쓸 수 있는 반복자. |
| 순방향 반복자(forward iterator)          | 1. 읽기/쓰기 가능.<br />2. 순방향 이동 및 ++ 연산이 가능한 __재할당이 될 수 있는 반복자__ |
| 양방향 반복자(bidirectional iterator)    | 1. 읽기/쓰기 모두 가능<br />2. 순/역방향 이동 및 --연산이 가능한 반복자. |
| 임의 접근 반복자(random access iterator) | 1. 읽기/쓰기 모두 가능<br />2. 임의 접근 가능<br />3. 양방향 반복자 기능에 +, -, +=, -=, []연산이 가능한 반복자 |

-> 모든 컨테이너들은 __양방향 반복자__ 이상의 기능을 제공함. __배열 기반의 컨테이너__ 즉, __vector와 deque__는 __임의 접근 반복자를 제공__



### 반복자의 개념을 포인터에 적용

```c++
#include <iostream>

using namespace std;

int main(){
  int arr[5] = {1, 2, 3, 4, 5};
  int *iter;
  
  for(iter=&arr[0]; iter != &arr[5]; iter++){
    cout<<(*iter)<<endl;
  }
  
  return 0;
}
```



### 벡터를 이용한 반복자

```c++
#include <iostream>
#include <vector>

using namespace std;

int main(){
  int arr[5] = {1, 2, 3, 4, 5};
  vector<int> v(&arr[0], &arr[5]);
  vector<int>::iterator iter;
  
  for(iter = v.begin(); iter != v.end(); iter++){
    cout<<(*iter)<<endl;
  }
  
  return 0;
}
```



### 리스트를 이용한 반복자

```c++
#include <iostream>
#include <list>

using namespace std;

int main(){
  int arr[5] = {1, 2, 3, 4, 5};
  list<int> v(&arr[0], &arr[5]);
  list<int>::iterator iter;
  
  for(iter = v.begin(); iter != v.end(); iter++){
    cout<<(*iter)<<endl;
  }
  return 0;
}
```



### 벡터와 리스트의 차이

- 반복자를 사용하는 도중에 벡터에서 값을 추가하는 push_back이나 값을 삭제하는 erase를 사용하면 __벡터 전체가 재할당__ 이 되어, 주솟값이 바뀌어 반복자가 __무효__ 가 됨.
- 하지만, list에서는 push_back이나 erase에서 요소들이 반복자를 무효화시키지 않고, 실제로 삭제된 요소를 가리키는 반복자만 무효화가 됨.